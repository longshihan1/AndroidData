# java部分

1. `HashMap` 和 `HashTable` 以及 `CurrentHashMap` 的区别。 一般来说，这三个东西基本在面试中 70% 会被问到，而问的方向也不太一样。比如初级的问法是讲讲它们之前的区别，这个我想没什么难度，大多数人还是知道主要核心区别是并发上的处理。此外，内部数据结构的实现、扩容、存取操作这些问题应该是很老生常谈了，这并没有什么好说的，大多数人也都知道。稍微问的深一点的可能会在下面这些点上出问题。**哈希碰撞，哈希计算，哈希映射，为什么是头插法，扩容为什么是 2 的幂次等这样的问题。**

   > 哈希：HashMap 采用一种所谓的“Hash [算法](http://lib.csdn.net/base/datastructure)”来决定每个元素的存储位置。当程序执行 map.put(String,Obect)方法 时，系统将调用String的 hashCode() 方法得到其 hashCode 值——每个 Java 对象都有 hashCode() 方法，都可通过该方法获得它的 hashCode 值。得到这个对象的 hashCode 值之后，系统会根据该 hashCode 值来决定该元素的存储位置。

   > 哈希碰撞：HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。HashMap底层是通过链表来解决hash冲突的。

   > 加载因子：加载因子越大,填满的元素越多,好处是,空间利用率高了,但冲突的机会加大了.链表长度会越来越长,查找效率降低。反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.表中的数据将过于稀疏（很多空间还没用，就开始扩容了）冲突的机会越大,则查找的成本越高.因此,必须在 "冲突的机会"与"空间利用率"之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的"时-空"矛盾的平衡与折衷.如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点；相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点。不过一般我们都不用去设置它，让它取默认值0.75就好了。

   > 扩容：首先，length为2的整数次幂的话，h&(length-1)就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率；其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&(length-1)的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。

2. ` synchronized` 和 `volatile` 、`ReentrantLock` 、CAS 的区别。 这个问题被问频率不在 `HashMap` 之下，因为并发编程，真的很重要。能问到这几个点的方式真的是太多了，我们能发挥的空间也同样很大。CAS 的 ABA 问题？上面几个东西的特性？使用场景？大概我不用再例举了吧？**对了，我多次被问到的一个问题是：synchronized 修饰实例方法和修饰静态方法有啥不一样。**

   > Synchronized修饰实例方法，实际上是对调用该方法的对象加锁，俗称“对象锁”
   >
   > 同一个对象在两个线程中分别访问该对象的两个同步实例方法:会产生互斥

   **原因**：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁之后才能执行

   > 不同对象在两个线程中分别调用同一个同步实例方法:不会互斥

   **原因**：因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。

   > Synchronized修饰静态方法，实际上是对该类对象，俗称“类锁”

   > 用类直接在两个线程中调用两个不同的同步静态方法:会产生互斥

   **原因**：因为对静态方法加锁，实际上是对类加锁，类只有一个。因此当一个同步静态方法被访问时，该类已处于被锁状态。此时其他同步静态方法不能被访问（未用Synchronized修饰的静态方法仍可以访问）

   > 用一个类的静态对象在两个线程中调用同步静态方法：会产生互斥

   **原因**：与**同一个对象在两个线程中分别访问该对象的两个同步实例方法**情况相同。本质上还是对类的加锁

   > 一个对象在两个线程中分别调用一个同步静态方法和一个同步实例方法：不会产生互斥

   **原因**：虽然是一个对象调用，但是两个方法的锁类型不同，调用静态方法实际上是对类对象在调用，而调用实例方法实际上是对实例对象在调用。因为这两个方法并不是一个对象锁，因为不会互斥，会并发执行

   > 结论：1、静态方法的锁和实例方法的锁，默认是不同的对象锁
   >
   > 2、静态方法加锁，能和该类中所有用synchronized修饰静态方法的相互互斥，和未用synchronized修饰的静态方法不互斥
   >
   > 3、静态方法锁实际是对类对象加锁，实例方法加锁实际是对实例对象加锁

3. JVM 类加载机制、垃圾回收算法对比、Java 虚拟机结构等。 这三个问题大概出现概率 40%，基本只需要看我每日一问系列的推文就差不多了吧，希望更清楚明白的可以直接看《深入理解 Java 虚拟机》。当你讲到分代回收算法的时候，不免会被追问到新生对象是怎么从年轻代到老年代的，以及可以作为 root 结点的对象有哪些两个问题。

    > JVM类加载机制：
    >
    > [详细介绍]("https://blog.csdn.net/feather_wch/article/details/81672834")
    >
    > ## 类加载机制

    ![](https://img-blog.csdn.net/20170705193002258?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbm9hbWFuX3dncw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

    加载，验证，准备，解析，初始化

    > 加载主要是将.class文件（并不一定是.class。可以是ZIP包，网络中获取）中的二进制字节流读入到JVM中。 
    > 在加载阶段，JVM需要完成3件事： 
    > 1）通过类的全限定名获取该类的二进制字节流； 
    > 2）将字节流所代表的静态存储结构转化为方法区的运行时数据结构； 
    >
    > 3）在内存中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

    > 2 连接
    > 2.1 验证
    > 验证是连接阶段的第一步，主要确保加载进来的字节流符合JVM规范。 
    > 验证阶段会完成以下4个阶段的检验动作： 
    > 1）文件格式验证 
    > 2）元数据验证(是否符合Java语言规范) 
    > 3）字节码验证（确定程序语义合法，符合逻辑） 
    > 4）符号引用验证（确保下一步的解析能正常执行）
    >
    > 2.2 准备
    > 准备是连接阶段的第二步，主要为静态变量在方法区分配内存，并设置默认初始值。
    >
    > 2.3 解析
    >
    > 解析是连接阶段的第三步，是虚拟机将常量池内的符号引用替换为直接引用的过程。

    > 3 初始化
    > 初始化阶段是类加载过程的最后一步，主要是根据程序中的赋值语句主动为类变量赋值。 
    > 注： 1）当有父类且父类为初始化的时候，先去初始化父类； 
    > 2）再进行子类初始化语句。
    >
    > 什么时候需要对类进行初始化？ 
    > 1）使用new该类实例化对象的时候； 
    > 2）读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）； 
    > 3）调用类静态方法的时候； 
    > 4）使用反射Class.forName(“xxxx”)对类进行反射调用的时候，该类需要初始化； 
    > 5） 初始化一个类的时候，有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）； 
    > 6） 被标明为启动类的类（即包含main()方法的类）要初始化； 
    > 7）当使用JDK1.7的动态语言支持时，如果一个java.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
    >
    > 以上情况称为对一个类进行主动引用，且有且只要以上几种情况需要对类进行初始化。

    > ## 类加载器
    >
    > 类加载器实现的功能是即为加载阶段获取二进制字节流的时候。
    >
    > JVM提供了以下3种系统的类加载器：
    >
    > 启动类加载器（Bootstrap ClassLoader）：最顶层的类加载器，负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。
    > 扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。
    > 应用程序类加载器(Application ClassLoader)：也叫做系统类加载器，可以通过getSystemClassLoader()获取，负责加载用户路径（classpath）上的类库。如果没有自定义类加载器，一般这个就是默认的类加载器。
    >
    > 类加载器之间的层次关系如下： 

    ![](https://img-blog.csdn.net/20170705193137597?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbm9hbWFuX3dncw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

    类加载器之间的这种层次关系叫做双亲委派模型。 
    双亲委派模型要求除了顶层的启动类加载器（Bootstrap ClassLoader）外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不是以继承关系实现的，而是用组合实现的。

    双亲委派模型的工作过程
    如果一个类接受到类加载请求，他自己不会去加载这个请求，而是将这个类加载请求委派给父类加载器，这样一层一层传送，直到到达启动类加载器（Bootstrap ClassLoader）。 
    只有当父类加载器无法加载这个请求时，子加载器才会尝试自己去加载。

    双亲委派模型的代码实现
    双亲委派模型的代码实现集中在java.lang.ClassLoader的loadClass()方法当中。 
    1）首先检查类是否被加载，没有则调用父类加载器的loadClass()方法； 
    2）若父类加载器为空，则默认使用启动类加载器作为父加载器； 
    3）若父类加载失败，抛出ClassNotFoundException 异常后，再调用自己的findClass() 方法。

    破坏双亲委派模型
    双亲委派模型很好的解决了各个类加载器加载基础类的统一性问题。即越基础的类由越上层的加载器进行加载。 
    若加载的基础类中需要回调用户代码，而这时顶层的类加载器无法识别这些用户代码，怎么办呢？这时就需要破坏双亲委派模型了。 
    下面介绍两个例子来讲解破坏双亲委派模型的过程。

    JNDI破坏双亲委派模型 
    JNDI是Java标准服务，它的代码由启动类加载器去加载。但是JNDI需要回调独立厂商实现的代码，而类加载器无法识别这些回调代码（SPI）。 
    为了解决这个问题，引入了一个线程上下文类加载器。 可通过Thread.setContextClassLoader()设置。 
    利用线程上下文类加载器去加载所需要的SPI代码，即父类加载器请求子类加载器去完成类加载的过程，而破坏了双亲委派模型。

    Spring破坏双亲委派模型 
    Spring要对用户程序进行组织和管理，而用户程序一般放在WEB-INF目录下，由WebAppClassLoader类加载器加载，而Spring由Common类加载器或Shared类加载器加载。 
    那么Spring是如何访问WEB-INF下的用户程序呢？ 
    使用线程上下文类加载器。 Spring加载类所用的classLoader都是通过Thread.currentThread().getContextClassLoader()获取的。当线程创建时会默认创建一个AppClassLoader类加载器（对应Tomcat中的WebAppclassLoader类加载器）： setContextClassLoader(AppClassLoader)。 
    利用这个来加载用户程序。即任何一个线程都可通过getContextClassLoader()获取到WebAppclassLoader。

    > [垃圾回收算法对比](https://blog.csdn.net/beyond59241/article/details/80191615)
    >
    > 标记-清除法
    >
    > 引用计数的算法
    >
    > GC 复制算法
    >
    > GC标记-压缩算法
    >
    > 保守式 GC
    >
    > 分代垃圾回收
    >
    > 增量式垃圾回收

    > Java 虚拟机结构 :
    >
    > Java 虚拟机的内存结构可以分为公有和私有两部分。公有指的是所有线程都共享的部分，指的是 Java 堆、方法区、常量池。私有指的是每个线程的私有数据，包括：PC寄存器、Java 虚拟机栈、本地方法栈。
    >
    > 1： **类加载子系统**（负责从文件系统或者网络中加载class信息，加载的类信息存放于一块成为方法区的内存空间。除了类信息外，方法区中可能还存放运行时常量池信息，包括字符串字面量和数字常量（这部分常量信息是class文件常量池部分的内存映射））
    >
    > 2：**java栈**（java方法的调用，保存着局部变量，方法参数，同时和java方法的调用、返回密切相关）
    >
    > 3：**方法区**（所有线程共享的内存区域，保存系统的类信息，比如类的字段、方法、常量池等）
    >
    > 4：**java堆**（在虚拟机启动的时候建立，它是java程序最主要的内存工作区域。几乎所有的java对象实例都存放于java堆中。堆空间是所有线程共享的，这是一块与java应用密切相关的内存区域）
    >
    > 5：**直接内存**（java的nio库允许java程序使用直接内存，参阅：[NIO之直接缓冲区与非直接缓冲区](https://www.cnblogs.com/shamo89/p/9612794.html)。直接内存是在java堆外的、直接向系统申请的内存区间。通常，访问直接内存的速度会优于java堆。因此，出于对性能的考虑，读写频繁的场合可能会考虑使用直接内存，由于直接内存在java堆外，因此直接内存的大小不会直接受限于xmx指定的最大堆大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存）
    >
    > 6：**本地方法栈**（本地方法的调用，这是java虚拟机的重要扩展，java虚拟机允许java直接调用本地方法（这个方法通常使用c编写））
    >
    > 7：**垃圾回收系统** （对方法区、java堆和直接内存进行回收。其中java堆是垃圾回收的重点。和c/c++ 不同，java中所有的对象空间释放是隐式的，也就是说对象的释放，开发人员不需要人为干预，对于不再使用的对象，垃圾回收系统会在后台自动查找、标识并释放垃圾对象，完成对java堆，方法区和直接内存中的全自动化管理）
    >
    > 8：**pc寄存器**（每个线程的私有空间，jvm会为每个java线程创建pc寄存器）
    >
    > 9：**执行引擎**（负责执行虚拟机的字节码）

    ![](https://img-blog.csdn.net/20180706152355951?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODA3ODYy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

    > 新生对象是怎么从年轻代到老年代:
    >
    > 一般来讲，对象首次创建的时候会被放置在新生代的eden区中，在对象经历一次GC后，会进入到s0或者s1区，在s0或者s1区中的对象“年龄”达到一定的大小，就会自动的离开年轻代进入老年代中，其中“对象的年龄”是由对象经历过得GC次数决定的。对于一个对象而言，在新生代每次GC之后，如果没有被回收则年龄增加1。可以通过-XX：MaxTenuringThreshold设定对象进入老年代的年龄阈值，超过这个阈值，就会进入到老年代中，默认情况为15.

    > 作为GC  root 结点的对象有哪些  [详细](https://www.jianshu.com/p/382c32538052)
    >
    > -  虚拟机栈（栈帧中的本地变量表）中引用的对象
    > -   本地方法栈中JNI（即一般说的Native方法）引用的对象
    > -   方法区中类静态属性引用的对象
    > -   方法区中常量引用的对象

4. Java 的四大引用 四大引用面试出现概率比我想象中要高，我原本以为就强引用、软引用、弱引用、虚引用这四个玩意儿没啥可讲的。实际上也确实没啥好讲的，稍微问的深一些的面试官会和内存泄漏检测原理以及垃圾回收糅杂在一起。

   > 强引用、软引用、弱引用、虚引用与垃圾回收内存泄漏检测
   >
   > 软引用（SoftReference ）：缓存
   >
   > 弱引用（WeakReference）：缓存（生命周期更短）
   >
   > 虚引用(PhantomReference):它不能决定引用对象的生命周期，常用来判断一个对象是否被清理掉，它get方法重写了，始终返回null。gc运行时对象只有虚引用，gc会对该值清理，因为对象可以重载finalize方法使对象复活。而且，如果重载finalize方法，不管有没有使对象复活，gc第二次才会标记清除该对象。
   >
   > 弱引用和虚引用的区别:
   >
   > 它们都不会延长对象的生命周期，gc总会当他们不存在一样，只是当对象清除了会把该引用设置为null。
   >
   > 它们不同在于对象finalize方法。如果将要清除的对象重载finalize方法，弱引用第一次就会清理，虚引用表现是第二次才会一样的。还有就是虚引用get()返回值总是null对象，弱引用只有垃圾回收了引用对象之后才会返回null。
   >
   > 用 WeakHashMap 代替 HashMap 



5. Java 的泛型，<? super T> 和 <? extends T> 的区别。 Java 泛型还是会在面试中出现的，不过几率不是很高，大概是因为我简历中有提到泛型擦除相关的东西。所以会被问到泛型、泛型擦除、通配符相关的东西。不过这个东西，不应该是为了应付面试，实际开发中真的很重要。
    > 泛型、泛型擦除、通配符
    >
    > 先检查，再编译以及编译的对象和引用传递问题
    >
    > 自动类型转换
    >
    > 类型擦除与多态的冲突和解决方法

6. Java 线程有哪些状态，有哪些锁，各种锁的区别。 这个问题讲真，我也只懂一点皮毛，并且当时回答不是很全面，出现概率的话，不是很高吧。

   >  线程的状态:创建->就绪->运行->阻塞->结束
   >
   > 锁分类：
   >
   > 1. 公平锁和非公平锁。
   >
   > ​       公平锁：是指按照申请锁的顺序来获取锁， 
   > ​      非公平所：线程获取锁的顺序不一定按照申请锁的顺序来的。
   >
   > ```java
   > //默认是不公平锁，传入true为公平锁，否则为非公平锁
   > ReentrantLock reentrantLock =  new ReetrantLock();
   > ```
   >
   > 2. 共享锁和独享锁 
   >    独享锁：一次只能被一个线程所访问 
   >    共享锁：线程可以被多个线程所持有。 
   >    ReadWriteLock 读锁是共享锁，写锁是独享锁。 
   >
   > 3. 乐观锁和悲观锁。 
   >    乐观锁：对于一个数据的操作并发，是不会发生修改的。在更新数据的时候，会尝试采用更新，不断重入的方式，更新数据。 
   >    悲观锁：对于同一个数据的并发操作，是一定会发生修改的。因此对于同一个数据的并发操作，悲观锁采用加锁的形式。悲观锁认为，不加锁的操作一定会出问题， 
   >
   > 4. 分段锁 
   >    1.7及之前的concurrenthashmap。并发操作就是分段锁，其思想就是让锁的粒度变小。 
   >
   > 5. 偏向锁
   >
   >    一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价 
   >    轻量级锁 
   >    重量级锁
   >
   > 6. 自旋锁 

7. `final` 、`finally`、`finalize` 区别。 老生常谈的问题，没啥好说的，实际上这次社招面试也只遇到了两次。比较喜欢追根溯源的面试官可能会对这个 `finalize` 有点执念，一定希望搞清楚，这玩意儿我们是不是可以真的搞点黑科技骚操作。

   finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。其实gc可以回收大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员去实现finalize的。 
   特殊情况下，需要程序员实现finalize，当对象被回收的时候释放一些资源，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。 
   使用finalize还需要注意一个事，调用super.finalize();

   一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象，所以有可能调用finalize()后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，产生问题。 所以，推荐不要使用finalize()方法，它跟析构函数不一样。

8. 接口和抽象类的区别。 没想到还被问了一次这个，这玩意儿给我的感觉就是随时都在用，但真要较真，还真不能一口气把所有区别都信手拈来。

   含有abstract修饰符的类即为抽象类，抽象类不能创建实例对象。含有抽象方法的类必须定义为abstract class。在abstract class中，方法不必是抽象的，但是抽象方法必须在具体子类中实现，所以，不能有抽象构造方法或抽象静态方法。子类如果没有实现抽象父类中的所有抽象方法，则必须定义为abstract类型。抽象类需要被继承才能使用，而被final修饰的类无法被继承，所以abstract和final是不能共存的。

   接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。**接口中的方法定义默认为 public abstract 类型 **，接口中的成员变量类型默认为public static final。

9. sleep` 、`wait`、`yield` 的区别，`wait` 的线程如何唤醒它？ 大多数 Android 应用开发并接触不到很多并发相关的东西，不过这玩意儿还是在面试中挺容易出现的。

   sleep:`Thread`类的静态方法，在指定的时间内让当前线程暂停执行，但**不会释放锁标志**也就是使线程进入阻塞`状态`

   wait:Object类的方法，在其他的线程调用`notify()/notifyAll()`之前，当前线程保持 等待，**会释放锁标志**，**其他线程可以在当前线程wait期间抢占锁**。**让线程进入等待(阻塞)状态**

   **wait与notify必须在synchronized函数中或者synchronized代码块中使用**，其他地方的使用虽然编译不会出错，但是会抛出异常。

   yield:只是让**当前的线程‘放弃cpu资源**，但是放弃的时间不确定，有可能放弃之后又获得了cpu资源。也就是，让线程**再次进入可执行状态**，yield只能使得同优先级或者优先级更高的线程获得执行的`可能`**yield不会释放锁**

   join:在一般情况下，往往主线程会先于其他线程执行结束。但是有时候主线程需要等待其他线程的执行结果，这时候就可以使用`join()`方法来让主线程暂停执行，先执行其他线程，直到其他线程执行完毕，主线程才会接着执行。也就是使得主线程阻塞，让调用`join()`的线程先执行。还有一个`join(long waitTime)`,可以使当前线程只阻塞 wait time 毫秒的时间。当调用`join()`方法的线程被中断的时候，程序会抛出异常

   **join(long time)的内部实现是使用的wait(long time)实现的，所以，在同步的代码中，会释放锁**。




