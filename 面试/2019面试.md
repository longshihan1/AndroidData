# java部分

1. `HashMap` 和 `HashTable` 以及 `CurrentHashMap` 的区别。 一般来说，这三个东西基本在面试中 70% 会被问到，而问的方向也不太一样。比如初级的问法是讲讲它们之前的区别，这个我想没什么难度，大多数人还是知道主要核心区别是并发上的处理。此外，内部数据结构的实现、扩容、存取操作这些问题应该是很老生常谈了，这并没有什么好说的，大多数人也都知道。稍微问的深一点的可能会在下面这些点上出问题。**哈希碰撞，哈希计算，哈希映射，为什么是头插法，扩容为什么是 2 的幂次等这样的问题。**

    

   > 哈希：HashMap 采用一种所谓的“Hash [算法](http://lib.csdn.net/base/datastructure)”来决定每个元素的存储位置。当程序执行 map.put(String,Obect)方法 时，系统将调用String的 hashCode() 方法得到其 hashCode 值——每个 Java 对象都有 hashCode() 方法，都可通过该方法获得它的 hashCode 值。得到这个对象的 hashCode 值之后，系统会根据该 hashCode 值来决定该元素的存储位置。

   > 哈希碰撞：HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。HashMap底层是通过链表来解决hash冲突的。

   > 加载因子：加载因子越大,填满的元素越多,好处是,空间利用率高了,但冲突的机会加大了.链表长度会越来越长,查找效率降低。反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.表中的数据将过于稀疏（很多空间还没用，就开始扩容了）冲突的机会越大,则查找的成本越高.因此,必须在 "冲突的机会"与"空间利用率"之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的"时-空"矛盾的平衡与折衷.如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点；相反如果机器内存紧张，并且对查询速度没有什么要求的话可以将加载因子设置大一点。不过一般我们都不用去设置它，让它取默认值0.75就好了。

   > 扩容：首先，length为2的整数次幂的话，h&(length-1)就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率；其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&(length-1)的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。

2. ` synchronized` 和 `volatile` 、`ReentrantLock` 、CAS 的区别。 这个问题被问频率不在 `HashMap` 之下，因为并发编程，真的很重要。能问到这几个点的方式真的是太多了，我们能发挥的空间也同样很大。CAS 的 ABA 问题？上面几个东西的特性？使用场景？大概我不用再例举了吧？**对了，我多次被问到的一个问题是：synchronized 修饰实例方法和修饰静态方法有啥不一样。**

   > Synchronized修饰实例方法，实际上是对调用该方法的对象加锁，俗称“对象锁”
   >
   > 同一个对象在两个线程中分别访问该对象的两个同步实例方法:会产生互斥

   **原因**：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁之后才能执行

   > 不同对象在两个线程中分别调用同一个同步实例方法:不会互斥

   **原因**：因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。

   > Synchronized修饰静态方法，实际上是对该类对象，俗称“类锁”

   > 用类直接在两个线程中调用两个不同的同步静态方法:会产生互斥

   **原因**：因为对静态方法加锁，实际上是对类加锁，类只有一个。因此当一个同步静态方法被访问时，该类已处于被锁状态。此时其他同步静态方法不能被访问（未用Synchronized修饰的静态方法仍可以访问）

   > 用一个类的静态对象在两个线程中调用同步静态方法：会产生互斥

   **原因**：与**同一个对象在两个线程中分别访问该对象的两个同步实例方法**情况相同。本质上还是对类的加锁

   > 一个对象在两个线程中分别调用一个同步静态方法和一个同步实例方法：不会产生互斥

   **原因**：虽然是一个对象调用，但是两个方法的锁类型不同，调用静态方法实际上是对类对象在调用，而调用实例方法实际上是对实例对象在调用。因为这两个方法并不是一个对象锁，因为不会互斥，会并发执行

   > 结论：1、静态方法的锁和实例方法的锁，默认是不同的对象锁
   >
   > 2、静态方法加锁，能和该类中所有用synchronized修饰静态方法的相互互斥，和未用synchronized修饰的静态方法不互斥
   >
   > 3、静态方法锁实际是对类对象加锁，实例方法加锁实际是对实例对象加锁

3. JVM 类加载机制、垃圾回收算法对比、Java 虚拟机结构等。 这三个问题大概出现概率 40%，基本只需要看我每日一问系列的推文就差不多了吧，希望更清楚明白的可以直接看《深入理解 Java 虚拟机》。当你讲到分代回收算法的时候，不免会被追问到新生对象是怎么从年轻代到老年代的，以及可以作为 root 结点的对象有哪些两个问题。

    > JVM类加载机制：
    >
    > ## 类加载机制

    ![](https://img-blog.csdn.net/20170705193002258?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbm9hbWFuX3dncw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

    加载，验证，准备，解析，初始化

    > 加载主要是将.class文件（并不一定是.class。可以是ZIP包，网络中获取）中的二进制字节流读入到JVM中。 
    > 在加载阶段，JVM需要完成3件事： 
    > 1）通过类的全限定名获取该类的二进制字节流； 
    > 2）将字节流所代表的静态存储结构转化为方法区的运行时数据结构； 
    >
    > 3）在内存中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

    > 2 连接
    > 2.1 验证
    > 验证是连接阶段的第一步，主要确保加载进来的字节流符合JVM规范。 
    > 验证阶段会完成以下4个阶段的检验动作： 
    > 1）文件格式验证 
    > 2）元数据验证(是否符合Java语言规范) 
    > 3）字节码验证（确定程序语义合法，符合逻辑） 
    > 4）符号引用验证（确保下一步的解析能正常执行）
    >
    > 2.2 准备
    > 准备是连接阶段的第二步，主要为静态变量在方法区分配内存，并设置默认初始值。
    >
    > 2.3 解析
    >
    > 解析是连接阶段的第三步，是虚拟机将常量池内的符号引用替换为直接引用的过程。

    > 3 初始化
    > 初始化阶段是类加载过程的最后一步，主要是根据程序中的赋值语句主动为类变量赋值。 
    > 注： 1）当有父类且父类为初始化的时候，先去初始化父类； 
    > 2）再进行子类初始化语句。
    >
    > 什么时候需要对类进行初始化？ 
    > 1）使用new该类实例化对象的时候； 
    > 2）读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）； 
    > 3）调用类静态方法的时候； 
    > 4）使用反射Class.forName(“xxxx”)对类进行反射调用的时候，该类需要初始化； 
    > 5） 初始化一个类的时候，有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）； 
    > 6） 被标明为启动类的类（即包含main()方法的类）要初始化； 
    > 7）当使用JDK1.7的动态语言支持时，如果一个java.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
    >
    > 以上情况称为对一个类进行主动引用，且有且只要以上几种情况需要对类进行初始化。

    > ## 类加载器
    >
    > 类加载器实现的功能是即为加载阶段获取二进制字节流的时候。
    >
    > JVM提供了以下3种系统的类加载器：
    >
    > 启动类加载器（Bootstrap ClassLoader）：最顶层的类加载器，负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。
    > 扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。
    > 应用程序类加载器(Application ClassLoader)：也叫做系统类加载器，可以通过getSystemClassLoader()获取，负责加载用户路径（classpath）上的类库。如果没有自定义类加载器，一般这个就是默认的类加载器。
    >
    > 类加载器之间的层次关系如下： 

    ![](https://img-blog.csdn.net/20170705193137597?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbm9hbWFuX3dncw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

    

    类加载器之间的这种层次关系叫做双亲委派模型。 
    双亲委派模型要求除了顶层的启动类加载器（Bootstrap ClassLoader）外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不是以继承关系实现的，而是用组合实现的。

    双亲委派模型的工作过程
    如果一个类接受到类加载请求，他自己不会去加载这个请求，而是将这个类加载请求委派给父类加载器，这样一层一层传送，直到到达启动类加载器（Bootstrap ClassLoader）。 
    只有当父类加载器无法加载这个请求时，子加载器才会尝试自己去加载。

    双亲委派模型的代码实现
    双亲委派模型的代码实现集中在java.lang.ClassLoader的loadClass()方法当中。 
    1）首先检查类是否被加载，没有则调用父类加载器的loadClass()方法； 
    2）若父类加载器为空，则默认使用启动类加载器作为父加载器； 

    3）若父类加载失败，抛出ClassNotFoundException 异常后，再调用自己的findClass() 方法。

    破坏双亲委派模型
    双亲委派模型很好的解决了各个类加载器加载基础类的统一性问题。即越基础的类由越上层的加载器进行加载。 
    若加载的基础类中需要回调用户代码，而这时顶层的类加载器无法识别这些用户代码，怎么办呢？这时就需要破坏双亲委派模型了。 
    下面介绍两个例子来讲解破坏双亲委派模型的过程。

    JNDI破坏双亲委派模型 
    JNDI是Java标准服务，它的代码由启动类加载器去加载。但是JNDI需要回调独立厂商实现的代码，而类加载器无法识别这些回调代码（SPI）。 
    为了解决这个问题，引入了一个线程上下文类加载器。 可通过Thread.setContextClassLoader()设置。 
    利用线程上下文类加载器去加载所需要的SPI代码，即父类加载器请求子类加载器去完成类加载的过程，而破坏了双亲委派模型。

    Spring破坏双亲委派模型 
    Spring要对用户程序进行组织和管理，而用户程序一般放在WEB-INF目录下，由WebAppClassLoader类加载器加载，而Spring由Common类加载器或Shared类加载器加载。 
    那么Spring是如何访问WEB-INF下的用户程序呢？ 
    使用线程上下文类加载器。 Spring加载类所用的classLoader都是通过Thread.currentThread().getContextClassLoader()获取的。当线程创建时会默认创建一个AppClassLoader类加载器（对应Tomcat中的WebAppclassLoader类加载器）： setContextClassLoader(AppClassLoader)。 
    利用这个来加载用户程序。即任何一个线程都可通过getContextClassLoader()获取到WebAppclassLoader。

    > 垃圾回收算法对比:

    > Java 虚拟机结构 :

    > 新生对象是怎么从年轻代到老年代:

    > 作为 root 结点的对象有哪些

4. Java 的四大引用 四大引用面试出现概率比我想象中要高，我原本以为就强引用、软引用、弱引用、虚引用这四个玩意儿没啥可讲的。实际上也确实没啥好讲的，稍微问的深一些的面试官会和内存泄漏检测原理以及垃圾回收糅杂在一起。

   > 强引用、软引用、弱引用、虚引用与垃圾回收内存泄漏检测



5. Java 的泛型，<? super T> 和 <? extends T> 的区别。 Java 泛型还是会在面试中出现的，不过几率不是很高，大概是因为我简历中有提到泛型擦除相关的东西。所以会被问到泛型、泛型擦除、通配符相关的东西。不过这个东西，不应该是为了应付面试，实际开发中真的很重要。
6. Java 线程有哪些状态，有哪些锁，各种锁的区别。 这个问题讲真，我也只懂一点皮毛，并且当时回答不是很全面，出现概率的话，不是很高吧。
7. `final` 、`finally`、`finalize` 区别。 老生常谈的问题，没啥好说的，实际上这次社招面试也只遇到了两次。比较喜欢追根溯源的面试官可能会对这个 `finalize` 有点执念，一定希望搞清楚，这玩意儿我们是不是可以真的搞点黑科技骚操作。
8. 接口和抽象类的区别。 没想到还被问了一次这个，这玩意儿给我的感觉就是随时都在用，但真要较真，还真不能一口气把所有区别都信手拈来。
9. sleep` 、`wait`、`yield` 的区别，`wait` 的线程如何唤醒它？ 大多数 Android 应用开发并接触不到很多并发相关的东西，不过这玩意儿还是在面试中挺容易出现的。

# 计算机网络

1. TCP 有哪些状态。
2. 三次握手、四次挥手。为啥是三次不是两次？
3. HTTPS 和 HTTP 的区别。HTTPS 2.0，3.0？
4. 浏览器输入一个 URL，按下回车网络传输的流程？
5. 喜欢深问一点的还会问到网络架构，每层有些什么协议，FTP 这些相关原理，印象比较深刻的还有一个问题是：TCP 建立连接后，发包频率是怎样的？

# Android部分

1. Activity 的生命周期；

2. Android 的 4 大启动模式，注意 `onNewIntent()` 的调用；

3. 组件化架构思路，如何从一个老项目一步一步实现组件化，主要问实现思路，考察应试者的架构能力和思考能力。 这一块内容真的很多，你需要考虑的问题很多，哪一步做什么，顺序很重要。

4. MVC、MCP、MVVP 的区别和各种使用场景，如何选择适合自己的开发架构？

5. Router 原理，如何实现组件间通信，组件化平级调用数据方式。

6. 系统打包流程；

7. APP 启动流程；

8. 如何做启动优化？ 冷启动什么的肯定是基础，后续应该还有的是懒加载，丢线程池同步处理，需要注意这里可能会有的坑是，丢线程池如何知道全部完成。

9. 事件分发机制。 事件分发已经不是直接让你讲了，会给你具体的场景，比如 A 嵌套 B ，B 嵌套 C，从 C 中心按下，一下滑出到 A，事件分发的过程，这里面肯定会有 ACTION_CANCEL 的相关调用时机。

10. 如何检测卡顿，卡顿原理是什么，怎么判断是页面响应卡顿还是逻辑处理造成的卡顿？

11. 生产者模式和消费者模式的区别？

12. 单例模式双重加锁，为什么要这样做。

13. Handler 机制原理，IdleHandler 什么时候调用。

14. LeakCanary 原理，为什么检测内存泄漏需要两次？

15. BlockCanary 原理。

16. ViewGroup 绘制顺序；

17. Android 有哪些存储数据的方式。

18. SharedPrefrence 源码和问题点；

19. 讲讲 Android 的四大组件；

20. 属性动画、补间动画、帧动画的区别和使用场景；

21. 自定义 ViewGroup 如何实现 FlowLayout？如何实现 FlowLayout 调换顺序？

22. 自定义 View 如何实现打桌球效果；

23. 自定义 View 如何实现拉弓效果，贝瑟尔曲线原理实现？

24. APK 瘦身是怎么做的，只用 armabi-v7a 没有什么问题么？ APK 瘦身这个基本是 100% 被面试问到，可能是我简历上提到的原因。

24. ListView 和 RecyclerView 区别？RecyclerView 有几层缓存，如何让两个 RecyclerView 共用一个缓存？

25. 如何判断一个 APP 在前台还是后台？

26. 如何做应用保活？全家桶原理？

27. 讲讲你所做过的性能优化。

28. Retrofit 在 OkHttp 上做了哪些封装？动态代理和静态代理的区别，是怎么实现的。

29. 讲讲轨迹视频的音视频合成原理；

30. AIDL 相关；

31. Binder 机制，讲讲 Linux 上的 IPC 通信，Binder 有什么优势，Android 上有哪些多进程通信机制?

32. RxJava 的线程切换原理。

33. OkHttp 和 Volloy 区别；

34. Glide 缓存原理，如何设计一个大图加载框架。

35. LRUCache 原理；

36. 讲讲咕咚项目开发中遇到的最大的一个难题和挑战； 这个问题基本是 95% 必问的一个问题；

37. 说说你开发最大的优势点。 出现率同上。

# 算法

1. String 转 int。 核心算法就三行代码，不过临界条件很多，除了判空，还需要注意负数、Integer 的最大最小值边界等；

2. 如何判断一个单链表有环？

3. 链表翻转；

4. 快排；

5. 100 亿个单词，找出出现频率最高的单词。要求几种方案；

6. 链表每 k 位逆序；

7. 镜像二叉树；

8. 找出一个无序数组中出现超过一半次数的数字；

9. 计算二叉树的最大深度，要求非递归算法。

10. String 方式计算加法



